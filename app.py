# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AZJ0doWQPmQK20Zb980iUCZos_LvUwOe
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
import openpyxl

st.set_option('deprecation.showPyplotGlobalUse', False)

# Function to calculate the Euclidean distance between two points
def euclidean_distance(point1, point2):
    return np.linalg.norm(np.array(point1) - np.array(point2))

# Function to create a distance matrix with row and column names
def create_distance_matrix(points):
    num_points = len(points)
    dist_matrix = pd.DataFrame(index=range(1, num_points + 1), columns=range(1, num_points + 1))

    for i in range(1, num_points + 1):
        for j in range(1, num_points + 1):
            dist_matrix.loc[i][j] = euclidean_distance(points[i - 1], points[j - 1])

    return dist_matrix

# Function to calculate the total distance of a tour
def calculate_total_distance(tour, dist_matrix):
    total_distance = 0

    for i in range(len(tour) - 1):
        total_distance += dist_matrix.loc[tour[i]][tour[i + 1]]  # Adjust row and column indices

    return total_distance

# Function to find the nearest neighbor TSP tour with a given distance matrix
def nearest_neighbor_tsp_with_matrix(dist_matrix, start_point=1):
    num_points = len(dist_matrix)
    unvisited = set(range(1, num_points + 1))
    tour = [start_point]
    unvisited.remove(start_point)

    while unvisited:
        current_point = tour[-1]
        nearest_point = min(unvisited, key=lambda x: dist_matrix.loc[current_point][x])  # Adjust row and column indices
        tour.append(nearest_point)
        unvisited.remove(nearest_point)

    tour.append(start_point)

    return tour

# Function to extract all routes for each possible starting point
def extract_all_routes(points):
    all_routes = []

    # Create the distance matrix with row and column names
    distance_matrix = create_distance_matrix(points)

    # Iterate through all possible starting points
    for start_point in range(1, len(points) + 1):
        # Find the nearest neighbor tour using the distance matrix
        tour = nearest_neighbor_tsp_with_matrix(distance_matrix, start_point)

        # Calculate the total distance for the current tour
        total_distance = calculate_total_distance(tour, distance_matrix)

        # Store the route in the list
        all_routes.append((tour, total_distance))

    return all_routes

# Function to find the nearest insertion TSP tour with a given set of points
def nearest_insertion(points):
    best_tour = None
    best_distance = float('inf')

    for starting_index, starting_point in enumerate(points):
        tour = [starting_point]
        unvisited = [p for p in points if p != starting_point]

        while unvisited:
            min_distance = float('inf')
            nearest_city = None
            insert_index = None

            for i, city in enumerate(unvisited):
                for j in range(len(tour)):
                    distance = euclidean_distance(city, tour[j]) + euclidean_distance(city, tour[(j + 1) % len(tour)]) - euclidean_distance(tour[j], tour[(j + 1) % len(tour)])
                    if distance < min_distance:
                        min_distance = distance
                        nearest_city = city
                        insert_index = j

            tour.insert(insert_index + 1, nearest_city)
            unvisited.remove(nearest_city)

        # Add the starting point to complete the closed tour
        tour.append(starting_point)

        tour_distance = sum(euclidean_distance(tour[i], tour[(i + 1) % len(tour)]) for i in range(len(tour)))

        if tour_distance < best_distance:
            best_distance = tour_distance
            best_tour = tour

        # Print the tour indices with starting point at the end
        print(f"Starting Index: {starting_index + 1}, Tour Indices: {[points.index(p) + 1 for p in tour]}, Total Distance: {tour_distance}")

    return best_tour, best_distance

# Function to visualize the TSP tour with arrows indicating direction
# Function to visualize the TSP tour with arrows indicating direction and distances
def visualize_tsp_tour_with_distances(points, tour):
    tour_points = [points[i - 1] for i in tour]  # Adjust indices

    # Unzip the points for plotting
    x, y = zip(*tour_points)

    # Increase the size of the figure
    plt.figure(figsize=(12, 10))

    # Plot the points
    plt.scatter(x, y, c='red', marker='o', label='Points')

    # Plot the TSP tour with arrows indicating direction
    for i in range(len(tour) - 1):
        plt.arrow(x[i], y[i], x[i + 1] - x[i], y[i + 1] - y[i], head_width=10, head_length=15, fc='blue', ec='blue')

    # Plot the starting point with a different marker
    plt.scatter(x[tour[0] - 1], y[tour[0] - 1], c='green', marker='s', s=100, label='Starting Point')

    # Annotate the points with their order and coordinates
    for i, txt in enumerate(tour):
        plt.annotate(txt, (x[i], y[i]),
                     textcoords="offset points", xytext=(0, 10), ha='center', va='bottom', color='red')
        plt.annotate(f"({points[txt - 1][0]}, {points[txt - 1][1]})", (x[i], y[i]),
                     textcoords="offset points", xytext=(0, -15), ha='center', va='top', color='black')

    # Add distances between points with a box
    for i in range(len(tour) - 1):
        distance = np.linalg.norm(np.array(tour_points[i]) - np.array(tour_points[i + 1]))
        plt.text((x[i] + x[i + 1]) / 2, (y[i] + y[i + 1]) / 2, f"{distance:.2f}", ha='center', va='center',
                 bbox=dict(boxstyle='round,pad=0.3', edgecolor='black', facecolor='white'))

    plt.title('TSP Tour Visualization with Distances')
    plt.xlabel('X-coordinate')
    plt.ylabel('Y-coordinate')
    plt.legend()
    st.pyplot()


# Function to extract all routes for each possible starting point using nearest insertion
def extract_all_routes_nearest_insertion(points):
    all_routes = []

    # Iterate through all possible starting points
    for starting_index, starting_point in enumerate(points):
        # Find the nearest insertion tour
        tour, total_distance = nearest_insertion(points[starting_index:] + points[:starting_index])

        # Add the starting point to the best tour indices
        best_tour_indices = [(points.index(p) + 1) for p in tour]

        # Store the route in the list
        all_routes.append((best_tour_indices, total_distance))

    return all_routes

# Streamlit UI
def main():
    st.title("TSP Solver with Streamlit")
    st.write("Rizky Ferdiansyah     6003221028")

    st.sidebar.header("Upload Data")
    uploaded_file = st.sidebar.file_uploader("Choose an XLSX file", type="xlsx")

    if uploaded_file is not None:
        # Read the uploaded file
        df = pd.read_excel(uploaded_file)

        # Display the uploaded data
        st.subheader("Uploaded Data:")
        st.write(df)

        # Extract all routes for nearest neighbor
        points = list(zip(df['X'], df['Y']))
        all_routes_nn = extract_all_routes(points)

        # Summarize routes in a DataFrame for nearest neighbor
        routes_df_nn = pd.DataFrame(all_routes_nn, columns=['Tour', 'Total Distance'])
        st.subheader("Summarized Routes (Nearest Neighbor):")
        st.dataframe(routes_df_nn)

        # Visualize the best route from nearest neighbor algorithm
        best_route_nn = all_routes_nn[routes_df_nn['Total Distance'].idxmin()]
        st.subheader("Best Route (Nearest Neighbor):")
        st.write(f"Tour: {best_route_nn[0]} with distance: {best_route_nn[1]}")

        visualize_tsp_tour_with_distances(points, best_route_nn[0])

        # Extract all routes for nearest insertion
        all_routes_insertion = extract_all_routes_nearest_insertion(points)

        # Summarize routes in a DataFrame for nearest insertion
        routes_df_insertion = pd.DataFrame(all_routes_insertion, columns=['Tour', 'Total Distance'])
        st.subheader("Summarized Routes (Nearest Insertion):")
        st.dataframe(routes_df_insertion)

        # Visualize the best route from nearest insertion algorithm
        best_route_insertion = all_routes_insertion[routes_df_insertion['Total Distance'].idxmin()]
        st.subheader("Best Route (Nearest Insertion):")
        st.write(f"Tour: {best_route_insertion[0]} with distance: {best_route_insertion[1]}")

        visualize_tsp_tour_with_distances(points, best_route_insertion[0])

if __name__ == "__main__":
    main()
